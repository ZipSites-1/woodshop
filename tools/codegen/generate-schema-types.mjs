#!/usr/bin/env node
import { fileURLToPath } from "node:url";
import { promises as fs } from "node:fs";
import path from "node:path";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const root = path.resolve(__dirname, "..", "..");
const schemaDir = path.join(root, "packages/schemas/src");
const schemaDistDir = path.join(root, "packages/schemas/dist");
const typesOutFile = path.join(root, "packages/types/src/index.ts");
const header = `// Auto-generated by tools/codegen/generate-schema-types.mjs. DO NOT EDIT.\n`;

const PROVENANCE_KEYS = new Set(["seed", "engine_versions", "revision_id", "inputs_hash"]);

function toTypeName(title, fileName) {
  if (title && typeof title === "string") {
    return title.replace(/[^A-Za-z0-9_]/g, "");
  }
  const base = fileName.replace(/\.schema\.json$/, "");
  return base
    .split(/[^A-Za-z0-9]+/)
    .filter(Boolean)
    .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
    .join("");
}

function indent(str, depth) {
  const pad = "  ".repeat(depth);
  return str
    .split("\n")
    .map((line) => (line.length ? pad + line : line))
    .join("\n");
}

function schemaType(schema, depth = 0) {
  if (schema === undefined || schema === null) {
    return "unknown";
  }
  if (schema.enum && Array.isArray(schema.enum) && schema.enum.length > 0) {
    return schema.enum.map((value) => JSON.stringify(value)).join(" | ");
  }
  const type = schema.type;
  if (Array.isArray(type)) {
    const uniqueTypes = Array.from(new Set(type));
    return uniqueTypes.map((t) => schemaType({ ...schema, type: t }, depth)).join(" | ");
  }
  switch (type) {
    case "string": {
      return "string";
    }
    case "integer":
    case "number": {
      return "number";
    }
    case "boolean": {
      return "boolean";
    }
    case "null": {
      return "null";
    }
    case "array": {
      const itemType = schema.items ? schemaType(schema.items, depth + 1) : "unknown";
      return `Array<${itemType}>`;
    }
    case "object":
    case undefined: {
      const properties = schema.properties || {};
      const required = new Set(schema.required || []);
      const lines = Object.keys(properties)
        .sort()
        .map((key) => {
          const propSchema = properties[key];
          const optional = required.has(key) ? "" : "?";
          const propType = schemaType(propSchema, depth + 1);
          return `${JSON.stringify(key)}${optional}: ${propType};`;
        });
      let extra = "";
      if (schema.additionalProperties && typeof schema.additionalProperties === "object") {
        extra = `[key: string]: ${schemaType(schema.additionalProperties, depth + 1)};`;
      } else if (schema.additionalProperties !== false) {
        extra = "[key: string]: unknown;";
      }
      if (extra) {
        lines.push(extra);
      }
      if (!lines.length) {
        return "Record<string, unknown>";
      }
      return `{
${indent(lines.join("\n"), 1)}
}`;
    }
    default:
      return "unknown";
  }
}

function extractToolName(fileName) {
  const parts = fileName.split(".");
  if (parts.length < 4) return null;
  return parts[0];
}

function extractSchemaRole(fileName) {
  const parts = fileName.split(".");
  if (parts.length < 4) return null;
  return parts[1];
}

async function main() {
  const files = (await fs.readdir(schemaDir)).filter((file) => file.endsWith(".schema.json"));
  files.sort();

  const declarations = [];
  const toolMap = new Map();

  await fs.mkdir(path.dirname(typesOutFile), { recursive: true });
  await fs.mkdir(schemaDistDir, { recursive: true });

  for (const file of files) {
    const filePath = path.join(schemaDir, file);
    const schema = JSON.parse(await fs.readFile(filePath, "utf8"));
    const typeName = toTypeName(schema.title, file);
    const typeBody = schemaType(schema);
    const decl = schema.type === "object" || schema.properties
      ? `export interface ${typeName} ${typeBody}`
      : `export type ${typeName} = ${typeBody};`;
    declarations.push(decl);

    const tool = extractToolName(file);
    const role = extractSchemaRole(file);
    if (tool && (role === "input" || role === "output")) {
      const entry = toolMap.get(tool) ?? {};
      entry[role] = typeName;
      toolMap.set(tool, entry);
    }

    const distTarget = path.join(schemaDistDir, file);
    await fs.copyFile(filePath, distTarget);
  }

  const sortedDeclarations = declarations.sort((a, b) => {
    const nameA = a.match(/export (?:interface|type)\s+(\w+)/)?.[1] ?? "";
    const nameB = b.match(/export (?:interface|type)\s+(\w+)/)?.[1] ?? "";
    return nameA.localeCompare(nameB);
  });

  const lines = [header, ...sortedDeclarations.map((decl) => `${decl}\n`)].join("\n");

  const toolNames = Array.from(toolMap.keys()).sort();
  const inputMapEntries = toolNames.map((name) => {
    const entry = toolMap.get(name) || {};
    return `  ${JSON.stringify(name)}: ${entry.input ?? "never"};`;
  });
  const outputMapEntries = toolNames.map((name) => {
    const entry = toolMap.get(name) || {};
    const outputType = entry.output ?? "never";
    return `  ${JSON.stringify(name)}: ${outputType};`;
  });

  const provenanceKeys = Array.from(PROVENANCE_KEYS)
    .map((key) => JSON.stringify(key))
    .join(" | ");

  const footer = `
export type ToolName = ${toolNames.map((n) => JSON.stringify(n)).join(" | ")};

export interface ToolInputMap {
${inputMapEntries.join("\n")}
}

export interface ToolOutputMap {
${outputMapEntries.join("\n")}
}

export type ProvenanceKey = ${provenanceKeys};
`;

  await fs.writeFile(typesOutFile, lines + footer, "utf8");
}

main().catch((error) => {
  console.error("[codegen] Failed to generate types:", error);
  process.exitCode = 1;
});
