#!/usr/bin/env node
import { fileURLToPath } from "node:url";
import { promises as fs } from "node:fs";
import path from "node:path";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const root = path.resolve(__dirname, "..", "..");
const schemaDir = path.join(root, "packages/schemas/src");
const schemaDistDir = path.join(root, "packages/schemas/dist");
const typesOutFile = path.join(root, "packages/types/src/index.ts");
const header = `// Auto-generated by tools/codegen/generate-schema-types.mjs. DO NOT EDIT.\n`;

const PROVENANCE_KEYS = new Set(["seed", "engine_versions", "revision_id", "inputs_hash"]);

function toTypeName(title, fileName) {
  if (title && typeof title === "string") {
    return title.replace(/[^A-Za-z0-9_]/g, "");
  }
  const base = fileName.replace(/\.schema\.json$/, "");
  return base
    .split(/[^A-Za-z0-9]+/)
    .filter(Boolean)
    .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
    .join("");
}

function indent(str, depth) {
  const pad = "  ".repeat(depth);
  return str
    .split("\n")
    .map((line) => (line.length ? pad + line : line))
    .join("\n");
}

function decodeJsonPointerToken(token) {
  return token.replace(/~1/g, "/").replace(/~0/g, "~");
}

function resolveJsonPointer(target, pointer) {
  if (!pointer || pointer === "") {
    return target;
  }
  const segments = pointer.split("/").map(decodeJsonPointerToken);
  let current = target;
  for (const segment of segments) {
    if (segment === "") {
      continue;
    }
    if (current && typeof current === "object" && segment in current) {
      current = current[segment];
    } else {
      return undefined;
    }
  }
  return current;
}

function normalizeRefPath(baseFile, refPath) {
  const baseDir = path.posix.dirname(baseFile);
  return path.posix.normalize(path.posix.join(baseDir, refPath));
}

function resolveRef(schemaCache, baseFile, ref) {
  let fileName = baseFile;
  let pointer = "";

  if (ref.includes("#")) {
    const [refPath, fragment] = ref.split("#");
    if (refPath) {
      fileName = normalizeRefPath(baseFile, refPath);
    }
    pointer = fragment ?? "";
  } else if (ref.startsWith("#")) {
    pointer = ref.slice(1);
  } else {
    fileName = normalizeRefPath(baseFile, ref);
  }

  const targetSchema = schemaCache.get(fileName);
  if (!targetSchema) {
    throw new Error(`Unable to resolve $ref '${ref}' from '${baseFile}'.`);
  }

  const resolved = resolveJsonPointer(targetSchema, pointer);
  if (resolved === undefined) {
    throw new Error(`JSON pointer '#${pointer}' not found in '${fileName}'.`);
  }

  return { schema: resolved, fileName };
}

function schemaType(schema, context, depth = 0) {
  if (schema === undefined || schema === null) {
    return "unknown";
  }
  if (schema.$ref) {
    const resolved = resolveRef(context.schemaCache, context.fileName, schema.$ref);
    return schemaType(resolved.schema, { ...context, fileName: resolved.fileName }, depth + 1);
  }
  if (Array.isArray(schema.allOf) && schema.allOf.length > 0) {
    for (const candidate of schema.allOf) {
      const candidateType = schemaType(candidate, context, depth + 1);
      if (candidateType !== "unknown") {
        return candidateType;
      }
    }
    return "unknown";
  }
  if (schema.enum && Array.isArray(schema.enum) && schema.enum.length > 0) {
    return schema.enum.map((value) => JSON.stringify(value)).join(" | ");
  }
  const type = schema.type;
  if (Array.isArray(type)) {
    const uniqueTypes = Array.from(new Set(type));
    return uniqueTypes
      .map((t) => schemaType({ ...schema, type: t }, context, depth))
      .join(" | ");
  }
  switch (type) {
    case "string": {
      return "string";
    }
    case "integer":
    case "number": {
      return "number";
    }
    case "boolean": {
      return "boolean";
    }
    case "null": {
      return "null";
    }
    case "array": {
      const itemType = schema.items
        ? schemaType(schema.items, { ...context }, depth + 1)
        : "unknown";
      return `Array<${itemType}>`;
    }
    case "object":
    case undefined: {
      const properties = schema.properties || {};
      const required = new Set(schema.required || []);
      const lines = Object.keys(properties)
        .sort()
        .map((key) => {
          const propSchema = properties[key];
          const optional = required.has(key) ? "" : "?";
          const propType = schemaType(propSchema, { ...context }, depth + 1);
          return `${JSON.stringify(key)}${optional}: ${propType};`;
        });
      let extra = "";
      if (schema.additionalProperties && typeof schema.additionalProperties === "object") {
        extra = `[key: string]: ${schemaType(schema.additionalProperties, { ...context }, depth + 1)};`;
      } else if (schema.additionalProperties !== false) {
        extra = "[key: string]: unknown;";
      }
      if (extra) {
        lines.push(extra);
      }
      if (!lines.length) {
        return "Record<string, unknown>";
      }
      return `{
${indent(lines.join("\n"), 1)}
}`;
    }
    default:
      return "unknown";
  }
}

function extractToolName(fileName) {
  const parts = fileName.split(".");
  if (parts.length < 4) return null;
  return parts[0];
}

function extractSchemaRole(fileName) {
  const parts = fileName.split(".");
  if (parts.length < 4) return null;
  return parts[1];
}

async function main() {
  const files = (await fs.readdir(schemaDir)).filter((file) => file.endsWith(".schema.json"));
  files.sort();

  const declarations = [];
  const toolMap = new Map();
  const schemaCache = new Map();

  for (const file of files) {
    const filePath = path.join(schemaDir, file);
    const schema = JSON.parse(await fs.readFile(filePath, "utf8"));
    schemaCache.set(file.replace(/\\/g, "/"), schema);
  }

  await fs.mkdir(path.dirname(typesOutFile), { recursive: true });
  await fs.mkdir(schemaDistDir, { recursive: true });

  for (const file of files) {
    const filePath = path.join(schemaDir, file);
    const schema = schemaCache.get(file.replace(/\\/g, "/"));
    const typeName = toTypeName(schema.title, file);
    const typeBody = schemaType(schema, { fileName: file.replace(/\\/g, "/"), schemaCache });
    const decl = schema.type === "object" || schema.properties
      ? `export interface ${typeName} ${typeBody}`
      : `export type ${typeName} = ${typeBody};`;
    declarations.push(decl);

    const tool = extractToolName(file);
    const role = extractSchemaRole(file);
    if (tool && (role === "input" || role === "output")) {
      const entry = toolMap.get(tool) ?? {};
      entry[role] = typeName;
      toolMap.set(tool, entry);
    }

    const distTarget = path.join(schemaDistDir, file);
    await fs.copyFile(filePath, distTarget);
  }

  const sortedDeclarations = declarations.sort((a, b) => {
    const nameA = a.match(/export (?:interface|type)\s+(\w+)/)?.[1] ?? "";
    const nameB = b.match(/export (?:interface|type)\s+(\w+)/)?.[1] ?? "";
    return nameA.localeCompare(nameB);
  });

  const lines = [header, ...sortedDeclarations.map((decl) => `${decl}\n`)].join("\n");

  const toolNames = Array.from(toolMap.keys()).sort();
  const inputMapEntries = toolNames.map((name) => {
    const entry = toolMap.get(name) || {};
    return `  ${JSON.stringify(name)}: ${entry.input ?? "never"};`;
  });
  const outputMapEntries = toolNames.map((name) => {
    const entry = toolMap.get(name) || {};
    const outputType = entry.output ?? "never";
    return `  ${JSON.stringify(name)}: ${outputType};`;
  });

  const provenanceKeys = Array.from(PROVENANCE_KEYS)
    .map((key) => JSON.stringify(key))
    .join(" | ");

  const footer = `
export type ToolName = ${toolNames.map((n) => JSON.stringify(n)).join(" | ")};

export interface ToolInputMap {
${inputMapEntries.join("\n")}
}

export interface ToolOutputMap {
${outputMapEntries.join("\n")}
}

export type ProvenanceKey = ${provenanceKeys};
`;

  await fs.writeFile(typesOutFile, lines + footer, "utf8");
}

main().catch((error) => {
  console.error("[codegen] Failed to generate types:", error);
  process.exitCode = 1;
});
